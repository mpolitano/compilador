import java_cup.runtime.*;
import java.io.FileReader;
import ir.ast.*;
import java.util.*;
//{: symTable=new SymbolTable(); symTable.pushLevel(); symTable.addSymbolToLevel(ID); :}   
/* Codigo del parser, se copia integramente a la clase final.
    Agregamos el manejo de errores. */

action code {:
    // Symbol table
    public SymbolTable symTable= new SymbolTable();
    
    public boolean inMethodDecl;
    public int cantMain;
    private LinkedList<Location> identifierList;

    public void report_error(String message, Object info) {
        StringBuilder m = new StringBuilder("Error");
        if (info instanceof Location) {
                m.append(" in line "+ (((Location)info).getLineNumber()+1));
                m.append(", column "+ (((Location)info).getColumnNumber()+1));
        }
        m.append(" : "+message);
        System.out.println(m + " " + ((Location)info).getId());
        System.exit(1); //Interrumpo la ejecucion
    }
:}

parser code{:
    
    /* Reporte de error encontrado. Modificamos */
    public void report_error(String message, Object info) {
        StringBuilder m = new StringBuilder("Error");
        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
            if (s.left >= 0) {                
                m.append(" in line "+(s.left+1));
                if (s.right >= 0)
                    m.append(", column "+(s.right+1));
            }
        }
        m.append(" : "+message);
        System.out.println(m + "  " + info.toString());
        System.exit(1); //Interrumpo la ejecucion
    }
  

    /* Metodo main para garantizar la ejecucion del analizador
       lexico y sintactico, ademas que se pase como parametro la tabla
       de simbolos correspondiente. */
    public static void main(String[] args){
        try {
            parser a = new parser(
            new AnalizadorLexico( new FileReader(args[0])));
            Object result = a.parse().value;
            System.out.println("---- PARSER COMPLETADO!! ------");
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }

:}

init with {: 
/*
               symTable= new SymbolTable();
               symTable.pushLevel(); 
               inMethodDecl= false;
*/               
             
          :}

  
   
// Terminales (tokens obtenidos por el analizador lexico).  

terminal  BREAK, CLASS, CONTINUE, ELSE,FALSE, FOR, IF, RETURN, TRUE, WHILE, LOWEREQUAL, 
          HIGHEREQUAL, HIGHER, LOWER, PLUS,SUB,MULT,DIVI,MOD, EQUAL,DIFFERENT, 
          PARENIZQ, PARENDER, PUNTOCOMA, COMA, NEG, OR, AND, 
          LLAB, LLCER, CORAB, CORCER, STRING, FLOAT, ASSIGPLUS,ASSIG,ASSIGSUB,EXTERNINVK;

terminal Location ID;
terminal Type RESERV_BOOLEAN, RESERV_INT, RESERV_FLOAT, VOID;
terminal IntLiteral INT;
// No Terminales (producciones).  
non terminal  PROGRAM, FIELD_DECL_STAR, METHOD_DECL_STAR, FIELD_DECL,METHOD_DECL,
              PARAMETERS, PARAMETER_PLUS, PARAMETER, BLOCK, STATAMENT_STAR, STATAMENT, ELSE_OPTIONAL,
              EXPR_OPTIONAL, ASSING_OP, METHOD_CALL, EXPR_COMA_OPTIONAL, EXPR_PLUS, EXTERNINVK_OPTIONAL, EXTERNINVK_PLUS, EXTERNINVK_ARG,
              LOCATION, LOCATION2, EXPR, BIN_OP, ARITH_OP, REL_OP, EQ_OP, COND_OP, LITERAL, BOOLEAN, PRUEBA;

non terminal Type TYPE;
non terminal LinkedList<Location> FIELD_PLUS;   
non terminal Location FIELD; 

// -------------Seccion de predencia y asociacion de los terminales----------- 
  
precedence left EQUAL, AND, NEG, DIFFERENT;
precedence left OR;
precedence left HIGHER, LOWER, LOWEREQUAL, HIGHEREQUAL;
precedence left PLUS, SUB;             
precedence left MULT, DIVI, MOD;      
precedence left TRUE, FALSE;   

// ------------------- Seccion de la gramatica ------------------------ 
   
// La gramatica 


start with PRUEBA ;

PRUEBA ::=     {:symTable= new SymbolTable();
               symTable.pushLevel(); 
               inMethodDecl= false;
               cantMain=0;
               identifierList=new LinkedList<Location>(); :} PROGRAM;


PROGRAM ::=             CLASS ID:ide LLAB FIELD_DECL_STAR METHOD_DECL_STAR LLCER {: 
                                  if(cantMain==0){
                                    report_error("Missing Main ", ide);          
                                  }
                                :}
              					| CLASS ID:ide LLAB METHOD_DECL_STAR LLCER{: 
                                  if(cantMain==0){
                                    report_error("Missing Main ", ide);          
                                  }
                                :};

FIELD_DECL_STAR ::=     FIELD_DECL_STAR FIELD_DECL
                        | FIELD_DECL;

FIELD_DECL  ::=	        TYPE:t FIELD_PLUS:decl {:System.out.println("++++"+t.toString());

                                                for (Location id:decl){
                                                  if(id instanceof VarLocation){ 
                                                    id.setType(t);                       
                                                  }else{//id instance of ArrayLocation                                      
                                                    id.setType(t.toArray());
                                                  } 
                                                  if(!symTable.addSymbolToLevel(id)){
                                                    report_error("Symbol Redefine: ", id);          
                                                  } 
                                                }
                                                identifierList=new LinkedList<Location>(); //Clean list for next fiels declaration 
                                                System.out.println(symTable.toString());
                                               :};

FIELD_PLUS ::=	        FIELD:f {:identifierList.add(f);:}COMA  FIELD_PLUS 
                        | FIELD:f PUNTOCOMA {:identifierList.add(f); RESULT=identifierList;:};

FIELD ::=               ID:ide CORAB INT:i CORCER {:RESULT= new ArrayLocation(ide.getId(),ide.getLineNumber(),ide.getColumnNumber(),ide.getBlockId(),i);:} //define a array's identifier
					              |ID:ide {: RESULT=ide; :};


METHOD_DECL_STAR  ::=   METHOD_DECL METHOD_DECL_STAR
                        | ;

METHOD_DECL ::= 	       TYPE:t ID:ide 
                         {:
                          if (ide.getId().equals("main")){
                            cantMain++;
                          }
                          if (ide.getId().equals("main")){
                            cantMain++;
                          }
                          inMethodDecl=true; //Set true flag inMethodDecl for drive levels
                          if(!symTable.addSymbolToLevel(ide)){//add symbol to current level for forbid declarate other symbol with same name, and check if it isn't refifined
                            report_error("Method Redefine: ",ide);
                          }
                          symTable.pushLevel();//push this method's level
                          ide.setType(t);//Set return type to method identifier
                          symTable.addSymbolToLevel(ide);//Add symbol to a method's level for forbid declarate variable with same name in method's block
                          symTable.pushLevel();
                        :} PARENIZQ PARAMETERS  PARENDER BLOCK
                        | VOID:t ID:ide {:
                                        if (ide.getId().equals("main")){
                                          cantMain++;
                                        }
                                        inMethodDecl=true; //Set true flag inMethodDecl for drive levels
                                        if(!symTable.addSymbolToLevel(ide)){//add symbol to current level for forbid declarate other symbol with same name, and check if it isn't refifined
                                          report_error("Method Redefine: ",ide);
                                        }
                                        symTable.pushLevel();//push this method's level
                                        ide.setType(t);
                                        symTable.addSymbolToLevel(ide);//Add symbol to a method's level for forbid declarate variable with same name in method's block
                                        symTable.pushLevel();
                                      :} PARENIZQ PARAMETERS  PARENDER BLOCK {: inMethodDecl=false;:};


PARAMETERS ::=            PARAMETER_PLUS
                        |  ;
					

PARAMETER_PLUS  ::=     PARAMETER COMA PARAMETER_PLUS 
                        | PARAMETER ;


PARAMETER ::=	          TYPE ID:ide {:symTable.addSymbolToLevel(ide);:} ;
  
BLOCK  ::=              LLAB  {:  if(!inMethodDecl){symTable.pushLevel();}else{inMethodDecl=false;} :} FIELD_DECL_STAR STATAMENT_STAR LLCER {: symTable.popLevel(); :}
                        |LLAB {:if(!inMethodDecl){symTable.pushLevel();}else{inMethodDecl=false;} :} STATAMENT_STAR LLCER {: symTable.popLevel(); :};


STATAMENT_STAR  ::=     STATAMENT STATAMENT_STAR 
            						| ;


TYPE::=                 RESERV_INT:t {:RESULT=t;:}|RESERV_BOOLEAN:t {:RESULT=t;:}|RESERV_FLOAT:t {:RESULT=t;:};


BOOLEAN  ::=            TRUE | FALSE ;


STATAMENT ::= 	        LOCATION ASSING_OP EXPR PUNTOCOMA
                				| METHOD_CALL PUNTOCOMA
                				| IF PARENIZQ EXPR PARENDER BLOCK ELSE_OPTIONAL
                				| FOR ID ASSIG EXPR COMA EXPR BLOCK
              			    | WHILE EXPR BLOCK
              			    | RETURN EXPR_OPTIONAL PUNTOCOMA 
              			    | BREAK PUNTOCOMA
              			    | CONTINUE PUNTOCOMA
              			    | PUNTOCOMA
              			    | BLOCK ;


ELSE_OPTIONAL  ::=      ELSE BLOCK
			               		| ;					

EXPR_OPTIONAL  ::=	   EXPR
					             | ;  


ASSING_OP  ::=         ASSIG | ASSIGPLUS | ASSIGSUB ;


METHOD_CALL  ::=       ID PARENIZQ EXPR_COMA_OPTIONAL PARENDER
              				| EXTERNINVK PARENIZQ STRING COMA VOID EXTERNINVK_OPTIONAL PARENDER 
              				|EXTERNINVK PARENIZQ STRING COMA TYPE EXTERNINVK_OPTIONAL PARENDER;


EXPR_COMA_OPTIONAL  ::= EXPR_PLUS 
                        | ;

EXPR_PLUS  ::=          EXPR COMA EXPR_PLUS 
                        | EXPR ;

EXTERNINVK_OPTIONAL ::= COMA EXTERNINVK_PLUS
                        | ;

EXTERNINVK_PLUS ::=	    EXTERNINVK_ARG COMA EXTERNINVK_PLUS 
                        | EXTERNINVK_ARG ;


EXTERNINVK_ARG ::=       EXPR | STRING ;

LOCATION  ::=           ID LOCATION2 ; //Debo verifificar que ID este en SymbolTable

LOCATION2  ::=          CORAB EXPR CORCER 
				                |;

EXPR  ::= 		          LOCATION
                				| METHOD_CALL
                				| LITERAL
                				| EXPR BIN_OP EXPR
              			    | SUB EXPR
              			    | NEG EXPR
              			    | PARENIZQ EXPR PARENDER ;


BIN_OP  ::=             ARITH_OP | REL_OP | EQ_OP | COND_OP ; 

ARITH_OP  ::=           PLUS|SUB|MULT|DIVI|MOD ;

REL_OP  ::=             HIGHER|HIGHEREQUAL|LOWER|LOWEREQUAL ;

EQ_OP  ::=              EQUAL | DIFFERENT ;

COND_OP  ::=            AND|OR ;

LITERAL  ::=            INT|BOOLEAN|FLOAT ; 
