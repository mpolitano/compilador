import java_cup.runtime.*;
import java.io.FileReader;
import ir.ast.*;
import java.util.*;
import ir.ASTVisitor;
import ir.semcheck.TypeCheckVisitor;
import ir.semcheck.BreakContinueCheckVisitor;
//{: symTable=new SymbolTable(); symTable.pushLevel(); symTable.addSymbolToLevel(ID); :}   
/* Codigo del parser, se copia integramente a la clase final.
    Agregamos el manejo de errores. */

action code {:
    // Symbol table
    public SymbolTable symTable= new SymbolTable();
    
    public boolean inMethodDecl;
    public int cantMain;

    public void report_error(String message, Object info) {
        StringBuilder m = new StringBuilder("Error");
        if (info instanceof Location) {
                m.append(" in line "+ (((Location)info).getLineNumber()+1));
                m.append(", column "+ (((Location)info).getColumnNumber()+1));
        }
        m.append(" : "+message);
        System.out.println(m + " " + ((Location)info).toString());
        System.exit(1); //Interrumpo la ejecucion
    }
:}

parser code{:
    
    /* Reporte de error encontrado. Modificamos */
    public void report_error(String message, Object info) {
        StringBuilder m = new StringBuilder("Error");
        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
            if (s.left >= 0) {                
                m.append(" in line "+(s.left+1));
                if (s.right >= 0)
                    m.append(", column "+(s.right+1));
            }
        }
        m.append(" : "+message);
        System.out.println(m + "  " + info.toString());
        System.exit(1); //Interrumpo la ejecucion
    }
  

    /* Metodo main para garantizar la ejecucion del analizador
       lexico y sintactico, ademas que se pase como parametro la tabla
       de simbolos correspondiente. */
    public static void main(String[] args){
        try {
            parser a = new parser(
            new AnalizadorLexico( new FileReader(args[0])));
            Program result = (Program)a.parse().value;
            TypeCheckVisitor typeCheckVisitor= new TypeCheckVisitor();
            result.accept(typeCheckVisitor);
            BreakContinueCheckVisitor breakCheckVisitor= new BreakContinueCheckVisitor();
            result.accept(breakCheckVisitor);
            int sizeErrorType = typeCheckVisitor.getErrors().size();
            int sizeErrorBreak= breakCheckVisitor.getErrors().size();
            switch(sizeErrorType){
              case 0:
                switch(sizeErrorBreak){
                  case 0:  System.out.println("---- PARSER COMPLETADO!! ------");
                  default: System.out.println(breakCheckVisitor.getErrors().toString());
             }
              default: if (sizeErrorBreak!=0){
                System.out.println(typeCheckVisitor.getErrors().toString());
                System.out.println(breakCheckVisitor.getErrors().toString());
              }else{
                System.out.println(typeCheckVisitor.getErrors().toString());
                } 
            }



         /*   if (typeCheckVisitor.getErrors().isEmpty() && breakCheckVisitor.getErrors().isEmpty()){
              System.out.println("---- PARSER COMPLETADO!! ------");
            }else{
              if (!(typeCheckVisitor.getErrors().isEmpty())){
                System.out.println(typeCheckVisitor.getErrors().toString());
              }if!(breakCheckVisitor.getErrors().isEmpty())){
                System.out.println(breakCheckVisitor.getErrors().toString());
              }else{
                System.out.println(breakCheckVisitor.getErrors().toString() + "\n" + System.out.println(typeCheckVisitor.getErrors().toString()););
              }
            }*/
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }

:}

init with {: 
/*
               symTable= new SymbolTable();
               symTable.pushLevel(); 
               inMethodDecl= false;
*/               
             
          :}

  
   
// Terminales (tokens obtenidos por el analizador lexico).  

terminal  BREAK, CLASS, CONTINUE, ELSE,FOR, IF, RETURN,WHILE,
          PARENIZQ, PARENDER, COMA,LLAB, LLCER, CORAB, CORCER,EXTERNINVK;

terminal Location ID;
terminal Type RESERV_BOOLEAN, RESERV_INT, RESERV_FLOAT, VOID;
terminal IntLiteral INT;
terminal SecStmt PUNTOCOMA;
terminal AssignOpType ASSIGSUB,ASSIG,ASSIGPLUS;
terminal StringLiteral STRING;
terminal FloatLiteral FLOAT;
terminal BooleanLiteral TRUE,FALSE;
terminal BinOpType  LOWEREQUAL,HIGHEREQUAL, HIGHER,LOWER,PLUS,SUB,MULT,DIVI,MOD, EQUAL,DIFFERENT, OR, AND;
terminal UnaryOpType NEG;

// No Terminales (producciones).  
                        
non terminal Program PRUEBA, PROGRAM;
non terminal Type TYPE;
non terminal List<Location> FIELD_PLUS;   
non terminal Location FIELD,LOCATION; 
non terminal List<Location> FIELD_DECL_STAR, FIELD_DECL;
non terminal List<MethodLocation> METHOD_DECL_STAR;
non terminal MethodLocation METHOD_DECL;
non terminal Block BLOCK;
non terminal List<Location> PARAMETERS, PARAMETER_PLUS;
non terminal Location PARAMETER;
non terminal List<Statement> STATAMENT_STAR;
non terminal Statement STATAMENT;
non terminal Block ELSE_OPTIONAL;
non terminal AssignOpType ASSING_OP;
non terminal Expression EXPR, EXPR_OPTIONAL,EXTERNINVK_ARG;
non terminal CallExpr METHOD_CALL;
non terminal List<Expression> EXPR_COMA_OPTIONAL,EXPR_PLUS,EXTERNINVK_OPTIONAL, EXTERNINVK_PLUS;
non terminal Literal LITERAL;
non terminal BooleanLiteral BOOLEAN;
non terminal BinOpType BIN_OP, ARITH_OP, REL_OP, EQ_OP, COND_OP;
// -------------Seccion de predencia y asociacion de los terminales----------- 
  
precedence left EQUAL, AND, NEG, DIFFERENT;
precedence left OR;
precedence left HIGHER, LOWER, LOWEREQUAL, HIGHEREQUAL;
precedence left PLUS, SUB;             
precedence left MULT, DIVI, MOD;      
precedence left TRUE, FALSE;   

// ------------------- Seccion de la gramatica ------------------------ 
   
// La gramatica 


start with PRUEBA ;

PRUEBA ::=     {:symTable= new SymbolTable();
               symTable.pushLevel(); 
               inMethodDecl= false;
               cantMain=0;
              :} PROGRAM:p{:RESULT=p;:};

PROGRAM ::=             CLASS ID:ide LLAB FIELD_DECL_STAR:listFiel METHOD_DECL_STAR:listMehod LLCER {: 
                                  if(cantMain==0){
                                    report_error("Missing Main ", ide);          
                                  }
                                  RESULT= new Program(ide.getId(),listFiel, listMehod);
                                :}
              					| CLASS ID:ide LLAB METHOD_DECL_STAR:listMehod LLCER{: 
                                  if(cantMain==0){
                                    report_error("Missing Main ", ide);          
                                  }
                                  RESULT= new Program(ide.getId(),new LinkedList<Location>(), listMehod);
                                :};

FIELD_DECL_STAR ::=     FIELD_DECL_STAR:fieldList FIELD_DECL:f {:fieldList.addAll(f); RESULT=fieldList;:}
                        | FIELD_DECL:f{:RESULT= new LinkedList<Location>(f); :};

FIELD_DECL  ::=	        TYPE:t FIELD_PLUS:decl {:

                                                for (Location id:decl){
                                                  if(id instanceof VarLocation){ 
                                                    id.setType(t);                       
                                                  }else{//id instance of ArrayLocation     
                                                    id.setType(t.toArray());
                                                    if (((ArrayLocation) id).getSize().getValue()<=0){
                                                      report_error("Wrong number for Array Size: ", id);                      
                                                    }
                                                  } 
                                                  if(!symTable.addSymbolToLevel(id)){
                                                    report_error("Symbol Redefine: ", id);          
                                                  } 
                                                }                                              
                                                RESULT=decl;
                                               :};

FIELD_PLUS ::=	        FIELD:f COMA  FIELD_PLUS:listId {:listId.add(f); RESULT=listId; :} 
                        | FIELD:f PUNTOCOMA {: List<Location> listId=new LinkedList<Location>();listId.add(f);RESULT=listId;:};

FIELD ::=               ID:ide CORAB INT:i CORCER {:RESULT= new ArrayLocation(ide.getId(),ide.getLineNumber(),ide.getColumnNumber(),-1,i);:} //define a array's identifier
					              |ID:ide {: RESULT=ide; :};


METHOD_DECL_STAR  ::=   METHOD_DECL:m METHOD_DECL_STAR:listMehod {: listMehod.add(m); RESULT=listMehod;:}
                        | {:RESULT= new LinkedList<MethodLocation>();:};

METHOD_DECL ::= 	       TYPE:t ID:ide 
                         {:
                          if (ide.getId().equals("main")){
                            cantMain++;
                          }
                          if (ide.getId().equals("main")){
                            cantMain++;
                          }
                          inMethodDecl=true; //Set true flag inMethodDecl for drive levels
                          MethodLocation newMethod= new MethodLocation(ide.getId());
                          newMethod.setType(t);//Set return type to method identifier
                          if(!symTable.addSymbolToLevel(newMethod)){//add symbol to current level for forbid declarate other symbol with same name, and check if it isn't refifined
                            report_error("Method Redefine: ",newMethod);
                          }
                          symTable.pushLevel();//push this method's level
                          symTable.addSymbolToLevel(newMethod);//Add symbol to a method's level for forbid declarate variable with same name in method's block
                          symTable.pushLevel();
                        :} 
                        PARENIZQ PARAMETERS:listParameters  PARENDER BLOCK:body
                        {:
                          MethodLocation newMethod=(MethodLocation) symTable.getByIde(ide.getId());
                          newMethod.setParameters(listParameters);
                          newMethod.setBody(body);                            
                          RESULT= newMethod; 
                        :}
                        | VOID:t ID:ide {:
                                        if (ide.getId().equals("main")){
                                          cantMain++;
                                        }
                                        inMethodDecl=true; //Set true flag inMethodDecl for drive levels
                                        MethodLocation newMethod= new MethodLocation(ide.getId());
                                        newMethod.setType(t);//Set return type to method identifier
                                        if(!symTable.addSymbolToLevel(newMethod)){//add symbol to current level for forbid declarate other symbol with same name, and check if it isn't refifined
                                          report_error("Method Redefine: ",newMethod);
                                        }
                                        symTable.pushLevel();//push this method's level
                                        newMethod.setType(t);
                                        symTable.addSymbolToLevel(newMethod);//Add symbol to a method's level for forbid declarate variable with same name in method's block
                                        symTable.pushLevel();
                                      :} 
                                      PARENIZQ PARAMETERS:listParameters  PARENDER BLOCK:body
                                                                        {: 
                                                                          MethodLocation newMethod= (MethodLocation) symTable.getByIde(ide.getId());
                                                                          newMethod.setParameters(listParameters);
                                                                          newMethod.setBody(body);                                                                          
                                                                          RESULT= newMethod;
                                                                        :};


PARAMETERS ::=          PARAMETER_PLUS:parametersList {:RESULT=parametersList;:}
                        | {:RESULT=new LinkedList<Location>();:};
					

PARAMETER_PLUS  ::=     PARAMETER:p COMA PARAMETER_PLUS:parametersList {:parametersList.add(p);RESULT=parametersList;:} 
                        | PARAMETER:p {:List<Location> parametersList= new LinkedList<Location>(); parametersList.add(p); RESULT=parametersList;:} ;


PARAMETER ::=	          TYPE:t ID:ide {:symTable.addSymbolToLevel(ide); ide.setType(t);RESULT=ide;:};
  
BLOCK  ::=              LLAB
                            {:
                              if(!inMethodDecl){
                                                symTable.pushLevel();
                                               }else{inMethodDecl=false;} 
                            :} 
                            FIELD_DECL_STAR:listField STATAMENT_STAR:listStatament LLCER
                            {:
                               symTable.popLevel();
                               RESULT= new Block(-1,listStatament); 
                            :}
                        
                       |LLAB {:
                              if(!inMethodDecl){
                                  symTable.pushLevel();
                              }else{inMethodDecl=false;}
                            :}
                            STATAMENT_STAR:listStatament LLCER {:
                                                    symTable.popLevel(); 
                                                    RESULT= new Block(-1,listStatament); 
                                                 :};


STATAMENT_STAR  ::=     STATAMENT:s STATAMENT_STAR:listStatament {: listStatament.add(s); RESULT=listStatament;:} 
            						| {:RESULT=new LinkedList<Statement>(); :};


TYPE::=                 RESERV_INT:t {:RESULT=t;:}|RESERV_BOOLEAN:t {:RESULT=t;:}|RESERV_FLOAT:t {:RESULT=t;:};


BOOLEAN  ::=            TRUE:t{:RESULT= t;:} | FALSE:f{:RESULT= f;:} ;


STATAMENT ::= 	        LOCATION:id ASSING_OP:op EXPR:expr PUNTOCOMA{:RESULT= new AssignStmt(id,op,expr);:}
                				| METHOD_CALL PUNTOCOMA{:RESULT= new SecStmt();:}
                				| IF PARENIZQ EXPR:boolExpr PARENDER BLOCK:b ELSE_OPTIONAL:else_optional{:RESULT= new IfStmt(boolExpr,b,else_optional);:}
                				| FOR ID:id ASSIG EXPR:iexpr COMA EXPR:fexpr BLOCK:body{:symTable.pushLevel(); id.setType(Type.INT);symTable.addSymbolToLevel(id);inMethodDecl=true;RESULT= new ForStmt(id,iexpr,fexpr,body);:}
              			    | WHILE EXPR:boolExpr BLOCK:body{:RESULT= new WhileStmt(boolExpr,body);:}
              			    | RETURN EXPR_OPTIONAL:expr PUNTOCOMA{: RESULT= new ReturnStmt(expr);:} 
              			    | BREAK PUNTOCOMA{:RESULT= new BreakStmt();:}
              			    | CONTINUE PUNTOCOMA{:RESULT= new ContinueStmt();:}
              			    | PUNTOCOMA:s{:RESULT=s;;:}
              			    | BLOCK:b {:RESULT=b;:};


ELSE_OPTIONAL  ::=      ELSE BLOCK:b{:RESULT= b;:}
			               		|{:RESULT= null;:} ;					

EXPR_OPTIONAL  ::=	   EXPR:expr {:RESULT=expr;:}
					             | {:RESULT=null;:};  


ASSING_OP  ::=         ASSIG:asign{: RESULT=asign;:} | ASSIGPLUS:asign {: RESULT=asign;:}| ASSIGSUB:asign{: RESULT=asign;:} ;


METHOD_CALL  ::=       ID:id PARENIZQ EXPR_COMA_OPTIONAL:actualParametersList PARENDER
                      {: 
                        Location m=symTable.getByIde(id.getId());
                        if (m==null || !(m instanceof MethodLocation)){
                          report_error("Method not defined: ",id);    
                        }else{
                          RESULT= new MethodCallExpr(((MethodLocation)m),actualParametersList);
                        }
                      :}                          
              				|EXTERNINVK PARENIZQ STRING:name COMA VOID:t EXTERNINVK_OPTIONAL:listParameters PARENDER{:RESULT= new ExterninvkCallExpr(name.getValue(),listParameters,t);:} 
              				|EXTERNINVK PARENIZQ STRING:name COMA TYPE:t EXTERNINVK_OPTIONAL:listParameters PARENDER{:RESULT= new ExterninvkCallExpr(name.getValue(),listParameters,t);:};


EXPR_COMA_OPTIONAL  ::= EXPR_PLUS:listExpr{:RESULT=listExpr;:} 
                        |{:RESULT= new LinkedList<Expression>();:};

EXPR_PLUS  ::=          EXPR:expr COMA EXPR_PLUS:listExpr{:listExpr.add(expr);RESULT=listExpr;:} 
                        | EXPR:expr{:List<Expression> listExpr=new LinkedList<Expression>(); listExpr.add(expr);RESULT=listExpr;:} ;

EXTERNINVK_OPTIONAL ::= COMA EXTERNINVK_PLUS:listExpr{:RESULT= listExpr;:}
                        |{: RESULT= new LinkedList<Expression>();:} ;

EXTERNINVK_PLUS ::=	    EXTERNINVK_ARG:expr COMA EXTERNINVK_PLUS:listExpr{:listExpr.add(expr);RESULT=listExpr;:} 
                        | EXTERNINVK_ARG:expr{:List<Expression> listExpr=new LinkedList<Expression>(); listExpr.add(expr);RESULT=listExpr;:};


EXTERNINVK_ARG ::=       EXPR:expr{:RESULT=expr;:} | STRING:str {:RESULT=str;:} ;

LOCATION  ::=           ID:id
                            {:
                              Location l= symTable.getByIde(id.getId()); 
                              if (l==null){
                                report_error("Symbol not defined :",id);
                              }else{
                                RESULT=l;                                
                              }                          
                            :} 
                        | ID:id CORAB EXPR CORCER
                          {:
                              Location l= symTable.getByIde(id.getId()); 
                              if (l==null){
                                report_error("Symbol not defined :",id);
                              }else{
                                RESULT=l;                                
                              }                          
                          :};


EXPR  ::= 		          LOCATION:l {:RESULT=l;:}
                				| METHOD_CALL:m{:RESULT= m;:}
                				| LITERAL:l{:RESULT= l;:}
                				| EXPR:lexpr BIN_OP:op EXPR:rexpr{:RESULT= new BinOpExpr(lexpr,op,rexpr);:}
              			    | SUB EXPR:expr{:RESULT= new UnaryOpExpr(UnaryOpType.MINUS,expr);:}//Here use a unary minus operator
              			    | NEG:op EXPR:expr{:RESULT= new UnaryOpExpr(op,expr);:}
              			    | PARENIZQ EXPR:expr PARENDER{:RESULT=expr;:};


BIN_OP  ::=             ARITH_OP:s{:RESULT=s;:} | REL_OP:s{:RESULT=s;:} | EQ_OP:s{:RESULT=s;:} | COND_OP:s{:RESULT=s;:} ; 

ARITH_OP  ::=           PLUS:s{:RESULT=s;:}|SUB:s{:RESULT=s;:}|MULT:s{:RESULT=s;:}|DIVI:s{:RESULT=s;:}|MOD:s{:RESULT=s;:} ;

REL_OP  ::=             HIGHER:s{:RESULT=s;:}|HIGHEREQUAL:s{:RESULT=s;:}|LOWER:s{:RESULT=s;:}|LOWEREQUAL:s{:RESULT=s;:};

EQ_OP  ::=              EQUAL:s{:RESULT=s;:} | DIFFERENT:s{:RESULT=s;:} ;

COND_OP  ::=            AND:s{:RESULT=s;:}|OR:s{:RESULT=s;:} ;

LITERAL  ::=            INT:i {:RESULT=i;:}|BOOLEAN:b {:RESULT=b;:}|FLOAT:f {:RESULT=f;:} ; 
