 
   
/* ---------------Seccion de STATAMENT_STAR preliminares--------------------*/
package compilador;

/* Import the class java_cup.runtime.*  */
import java_cup.runtime.*;
import java.io.FileReader;
   
/* Codigo del parser, se copia integramente a la clase final.
    Agregamos el manejo de errores. */
parser code {:
    
    /* Reporte de error encontrado. */
    public void report_error(String message, Object info) {
        StringBuilder m = new StringBuilder("Error");
        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
            if (s.left >= 0) {                
                m.append(" in line "+(s.left+1));
                if (s.right >= 0)
                    m.append(", column "+(s.right+1));
            }
        }
        m.append(" : "+message);
        System.err.println(m);
    }
   
    /* Cuando se encuentra un error de donde el sistema no puede
        recuperarse, se lanza un error fatal. Se despliega el mensaje
        de error y se finaliza la ejecucion. */
    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }

    /* Metodo main para garantizar la ejecucion del analizador
       lexico y sintactico, ademas que se pase como parametro la tabla
       de simbolos correspondiente. */
    public static void main(String[] args){
        try {
            analizadorSintactico a = new AnalizadorSintactico(
                    new AnalizadorLexico( new FileReader(args[0])));
            Object result = a.parse().value;
            System.out.println("\n*** Resultados finales ***");
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }
:};

   
   
/* ------------STATAMENT de simbolos terminales y no terminales---------- */
   
/* Terminales (tokens obtenidos por el analizador lexico).  

   Terminales que no tienen un valor son listados primero, los terminales que
   tienen un valor como los enteros son listados en la segunda o demas lineas. */
terminal  BREAK, CLASS, CONTINUE, ELSE,FALSE, FOR, IF, RETURN, TRUE, VOID, WHILE, LOWEREQUAL, 
          HIGHEREQUAL, HIGHER, LOWER, PLUS,SUB,MULT,DIVI,MOD, EQUAL,DIFFERENT, 
          PARENIZQ, PARENDER, PUNTOCOMA, COMA, NEG, OR, AND, 
          LLAB, LLCER, CORAB, CORCER, ID, STRING, FLOAT, ASIGPLUS,ASSIG,ASSIGSUB,EXTERNINVK,RESERV_FLOAT,RESERV_INT, RESERV_BOOLEAN, INT;

non terminal  PROGRAM, FIELD_DECL_STAR, METHOD_DECL_STAR, FIELD_DECL, FIELD_PLUS, FIELD,METHOD_DECL,
              PARAMETERS, PARAMETER_PLUS, PARAMETER, BLOCK, STATAMENT_STAR, TYPE, STATAMENT, ELSE_OPTIONAL,
              EXPR_OPTIONAL, ASSING_OP, METHOD_CALL, EXPR_COMA_OPTIONAL, EXPR_PLUS, EXTERNINVK_OPTIONAL, EXTERNINVK_PLUS, EXTERNINVK_ARG,
              LOCATION, LOCATION2, EXPR, BIN_OP, ARITH_OP, REL_OP, EQ_OP, COND_OP, LITERAL, BOOLEAN;
   
/* -------------Seccion de predencia y asociacion de los terminales----------- */
  
precedence left EQUAL, AND, NEG, DIFFERENT;
precedence left OR;
precedence left HIGHER, LOWER, LOWEREQUAL, HIGHEREQUAL;
precedence left PLUS, SUB;             
precedence left MULT, DIVI, MOD;      
precedence left TRUE, FALSE;   

/* ------------------- Seccion de la gramatica ------------------------ */
   
/* La gramatica de nuestro analizador.*/


start with PROGRAM ;

PROGRAM ::= CLASS ID LLAB FIELD_DECL_STAR METHOD_DECL_STAR LLCER 
						| CLASS ID LLAB METHOD_DECL_STAR LLCER;

FIELD_DECL_STAR ::= FIELD_DECL_STAR FIELD_DECL| FIELD_DECL;

FIELD_DECL  ::=	TYPE FIELD_PLUS ;

FIELD_PLUS ::=	FIELD_PLUS COMA FIELD| FIELD;

FIELD ::=  ID CORAB INT CORCER
					 |ID;


METHOD_DECL_STAR  ::=   METHOD_DECL METHOD_DECL_STAR
                        | ;

METHOD_DECL ::= 	TYPE ID PARENDER PARAMETERS  PARENIZQ BLOCK| VOID ID PARENDER PARAMETERS  PARENIZQ BLOCK ;


PARAMETERS ::= PARAMETER_PLUS 
					| ;

PARAMETER_PLUS  ::=	PARAMETER COMA PARAMETER_PLUS | PARAMETER ;

PARAMETER ::=	TYPE ID ;
  
BLOCK  ::=  LLAB FIELD_DECL_STAR STATAMENT_STAR LLCER ;

STATAMENT_STAR  ::= STATAMENT STATAMENT_STAR 
						| ;


TYPE::= RESERV_INT|RESERV_BOOLEAN|RESERV_FLOAT ;

BOOLEAN  ::= TRUE | FALSE ;


STATAMENT ::= 	LOCATION ASSING_OP EXPR PUNTOCOMA
  				| METHOD_CALL PUNTOCOMA
  				| IF PARENIZQ EXPR PARENDER BLOCK ELSE_OPTIONAL
  				| FOR ID ASSIG EXPR COMA EXPR BLOCK
			    | WHILE EXPR BLOCK
			    | RETURN EXPR_OPTIONAL PUNTOCOMA 
			    | BREAK PUNTOCOMA
			    | CONTINUE PUNTOCOMA
			    | PUNTOCOMA
			    | BLOCK ;


ELSE_OPTIONAL  ::= ELSE BLOCK
					| ;					

EXPR_OPTIONAL  ::=	EXPR
					| ;

ASSING_OP  ::= ASSIG | ASIGPLUS | ASSIGSUB ;

METHOD_CALL  ::= ID PARENIZQ EXPR_COMA_OPTIONAL PARENDER
					| EXTERNINVK PARENIZQ STRING COMA VOID EXTERNINVK_OPTIONAL PARENDER 
					|EXTERNINVK PARENIZQ STRING COMA TYPE EXTERNINVK_OPTIONAL PARENDER;


EXPR_COMA_OPTIONAL  ::= EXPR_PLUS 
                    | ;

EXPR_PLUS  ::= EXPR COMA EXPR_PLUS | EXPR ;

EXTERNINVK_OPTIONAL ::= COMA EXTERNINVK_PLUS
                      | ;

EXTERNINVK_PLUS ::=	EXTERNINVK_ARG COMA EXTERNINVK_PLUS | EXTERNINVK_ARG ;

EXTERNINVK_ARG ::= EXPR | STRING ;

LOCATION  ::= ID LOCATION2 ;

LOCATION2  ::= CORAB EXPR CORCER
				|;

EXPR  ::= 		LOCATION
  				| METHOD_CALL
  				| LITERAL
  				| EXPR BIN_OP EXPR
			    | SUB EXPR
			    | NEG EXPR
			    | PARENIZQ EXPR PARENDER ;


BIN_OP  ::= ARITH_OP | REL_OP | EQ_OP | COND_OP ; 

ARITH_OP  ::= PLUS|SUB|MULT|DIVI|MOD ;

REL_OP  ::= HIGHER|HIGHEREQUAL|LOWER|LOWEREQUAL ;

EQ_OP  ::= EQUAL | DIFFERENT ;

COND_OP  ::= AND|OR ;

LITERAL  ::= INT|BOOLEAN|FLOAT ; 
